算法简介：
一、数据结构与算法的关系
虽然本门课程叫“数据结构”，但经常会讲到算法，以及它们之间的关系。在市面上也经常有诸如“数据结构与算法分析”这样名字的书。
实际上，数据结构与算法是依存关系。只谈数据结构而抛弃算法，则数据是“死”的，没有活力的；只谈算法而抛弃数据结构，则算法无法有所依赖的操作对象，只是空谈。对于程序来说，数据结构赋予其血肉骨骼，算法赋予其灵魂思想，二者合一才是完整的程序，二者缺一不可。因此，我们在学习数据结构的时候，经常要学习算法的相关知识。
二、算法定义
定义：算法（Algorithm）：算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个动作。
对于给定的问题，是可以有多种算法来解决的。
现实世界中问题千奇百怪，算法当然也就千变万化，没有通用的算法可以解决所有的问题。甚至对于一些问题，优秀的算法却不见得适合它。（例如，对于数据量较少（万以下）的数据排序，快速排序算法的执行效率并没有比冒泡排序快上很多。）
算法示例：辗转相除法求两个正整数的最大公约数
辗转相除法，又名欧几里得算法（Euclidean algorithm），3000年前由欧几里得在其著作《几何原本》中提出，是世界上已知最古老的算法。
算法描述：设两数为a、b（a>b），求最大公约数的步骤如下：
⒈用a除以b，得到其商q和余数r
⒉若r=0，则最大公约数就是b，算法结束
⒊若r!=0，则令a=b，b=r
⒋循环执行，回到步骤1
代码描述：
/************
*函数Euclidean_algorithm()
*入参：两个整数int m,int n
*返回值：两数的最大公约数
*功能：计算两个数的最大公约数
**************/
int Euclidean_algorithm(int m,int n)
{
	int r;
	do{
		r=m%n;
		m=n;
		n=r;
	}while(r!=0);
	return m;
}
构造一个算法的常见方法有：递推法、递归法、穷举法、贪心法、分治法、动态规划法、迭代法、分支界限法、回溯法等。
一些大名鼎鼎的算法：
⒈辗转相除法：已知世界上最古老的算法
⒉割圆术：刘徽首创，祖冲之改进，计算圆周率
⒊秦九韶算法：大大简化多项式的计算
⒋快速排序算法：20世纪十大算法之一
⒌赫夫曼编码：数据压缩的基本算法
⒍RSA加密：现代计算机网络数据加密算法的基础
⒎蒙特卡洛搜索树算法：人工智能基础算法，让计算机“可以像人类般思考”的算法
三、算法的特性
算法具有5个基本特性：输入、输出、有穷性、确定性、可行性
1、输入输出：
算法具有0个或多个输入，至少有1个输出。输出的形式可以是打印字符，也可以是返回值等形式。
2、有穷性：
有穷性：指算法在执行有限的步骤后，自动结束而不会出现无限循环，并且每个步骤在可接受的时间内完成。
3、确定性：
确定性：算法的每一步骤都具有确定的含义而不会出现二义性。算法在一定条件下，只有一条执行路径，相同的输入只能得到唯一的输出结果。算法的每个步骤被精确定义而无歧义。
4、可行性：
可行性：算法的每一步必须是可行的，也就是说，每一步都可以通过执行有限次数完成。可行性意味着算法可以转换成上机程序并得到正确结果。
四、算法设计要求
好的算法，应该具有正确性、可读性、健壮性、高效率和低存储量的特征。
1、正确性：
正确性：算法的正确性是指算法至少应该具有输入、输出和加工处理无歧义性、能正确反应问题的需求、能够得到问题的正确答案。
算法的正确性大体上分为4个层次：
⒈算法程序没有语法错误；
⒉算法程序对于合法的输入数据能够产生满足要求的输出结果；
⒊算法程序对于非法的输入能够得出满足规格说明的信息；
⒋算法程序对于精心选择的、甚至刁难的测试数据都有满足要求的输出结果。
证明一个复杂算法的正确性需要数学推导方法的证明，而若证明以上4个层次都正确的话代价非常昂贵，因此一般情况下，我们把层次3作为一个算法是否具有正确性的标准。
2、可读性：
可读性：算法设计的另一目的是为了方便阅读、理解和交流。
可读性高有助于人们理解算法，晦涩难懂的算法往往会隐含错误，不易被发现，并且难于实现、调试和修改。
有时，我们可能为了追求极致（例如致力于用最少的代码来描述算法）而书写出一些难以理解的算法，这样的代码真的不好理解，也许除了计算机自己，没几个人能读懂这样的代码。可读性是算法（也包括实现该算法的代码）好坏的很重要的指标。
3、健壮性：
健壮性：当输入数据不合法时，算法也能做出相关的处理，而不会产生异常或输出莫名其妙的结果。
一个好的算法还应能对输入数据不合法的情况做出合适的处理，例如若输入的不能为负数（例如时间、年龄、工号、距离等）的数据为负数时算法要能够报错。
4、时间效率高和存储量低：
最后，好的算法还应具备时间效率高和存储量低的特点。
五、算法效率的度量方法
1、事后统计方法
事后统计方法：这种方法主要是通过设计好的测试程序和数据，利用计算机计时器对不同算法编制的计算机程序的运行时间进行比较，从而确定算法运行效率的高低。
2、事前分析估算方法
事前分析估算方法：在计算机程序编写前，根据统计方法对算法进行估算。
一个用高级语言编写的程序在计算机上运行时间取决于以下因素：
⒈算法采用的策略、方法
⒉编译产生的代码质量
⒊问题的输入规模
⒋机器执行指令的速度
其中第1条是算法好坏的根本，第2条取决于软件，第4条取决于硬件性能。也就是说，一个程序的运行时间，依赖于算法的好坏和输入的规模。
六、算法的时间复杂度
1、算法的时间复杂度与大O记法
定义：算法的时间复杂度：在进行算法分析时，语句总的执行次数T(n)是一个关于问题规模n的函数，进而分析T(n)随n的变化情况确定T(n)的数量级。算法的时间复杂度记做：T(n)=O(f(n))，它表示随着问题规模n的增大，算法执行时间的增长率和函数f(n)的增长率相同，称作算法的渐进时间复杂度，简称为时间复杂度。其中f(n)是问题规模n的某个函数。
这样用O()来体现算法时间复杂度的记法，我们称之为大O记法。
大O记法表示算法时间复杂度增长率的上限，即随着数据规模n的增大，所耗时的可能最大增长率。
2、推导大O阶的方法
已知语句执行次数T(n)，推导一个算法时间复杂度大O阶的方法如下：
⒈用常数1取代T(n)中的所有加法常数
⒉在修改后的运行次数函数中，只保留最高阶项
⒊如果最高阶项存在且不是1，则去除与这个项相乘的常数
示例：分析以下算法的时间复杂度
void MATRIXM(int n)
{
	float A[n][n],B[n][n],C[n][n];
	int i,j,k;
	for(i=0;i<n;i++)
	{
		for(j=0;j<n;j++)
		{
			C[i][j]=0;
			for(k=0;k<n;k++)
			{
				C[i][j]=C[i][j]+A[i][k]*B[j][k];
			}
		}
	}
}
第一步：计算语句执行次数T(n)
对于算法来说，我们要求得语句执行次数，需要先分析每一条语句的语句频度。对于以上代码来说，其每一条语句的语句频度为：
void MATRIXM(int n)								该语句的语句频度
{
	float A[n][n],B[n][n],C[n][n];
	int i,j,k;
	for(i=0;i<n;i++)-------------------------------->n+1次
	{
		for(j=0;j<n;j++)---------------------------->n*(n+1)次
		{
			C[i][j]=0;------------------------------>n^2次
			for(k=0;k<n;k++)------------------------>n^2 * (n+1)次
			{
				C[i][j]=C[i][j]+A[i][k]*B[j][k];---->n^3次
			}
		}
	}
}
将以上每个语句频度相加，得到
T(n)=2*n^3+3*n^2+2*n+1
第二步：保留最高次项
T(n)----->O(2*n^3)
第三步：去除最高次项系数
T(n)----->O(n^3)
即T(n)=O(n^3)
练习：自定义一个一维数组，编写查找该数组中最大元素的算法，并分析其时间复杂度
答案：
//代码略
该算法的时间复杂度为O(n)
定理：若A(n)=am*n^m+……+a1*n+a0是一个m次多项式，则A(n)=O(n^m)
3、常见时间复杂度
从计算时间上可以把算法分成两类：可以用多项式来对其计算时间限界的算法，称为多项式时间算法（polynomial time algorithm）；而计算时间用指数函数限界的算法称为指数时间算法（exponential time algorithm）。
常见的多项式时间算法有O(1)、O(logn)、O(n)、O(nlogn)、O(n2)、O(n3)。
常见的指数时间算法有O(2^n)、O(n!)、O(n^n)。
以下是常见的一些T(n)的时间复杂度O(n)
//见附图1
常用算法的时间复杂度所耗费的时间从小到大依次是：
O(1) < O(logn) < O(n) < O(nlogn) < O(n^2) < O(n^3) < O(2^n) < O(n!) < O(n^n)
对于O(n^3)以及以后的时间复杂度，过大的n都会使得算法耗时大大增加，因此过于大的时间复杂度一般不予讨论。
4、最坏情况与平均情况
针对不同的数据n，同样的算法所运行的时间也不完全相同。例如在n个数据中查找一个数据，最好情况是第一个数据就是，那么这时的时间复杂度就是O(1)，而最坏的情况就是数据在最后，那么这时的时间复杂度就是O(n)。最坏情况运行时间是一种保证，即运行时间不会更坏。通常情况下，若无特殊指定，算法的时间复杂度都指最坏情况下的时间复杂度。
而平均情况的时间复杂度是从概率角度来看，这个数据在每一个位置是完全随机的。平均运行时间是所有情况中最有意义的，因为它是期望的运行时间。可在现实中，平均运行时间很难通过事前分析得到，需要运行一定量的实验数据后估算出来。
七、算法空间复杂度
算法的空间复杂度通过计算算法所需的存储空间实现，算法的空间复杂度记做S(n)=O(f(n))，其中n为问题的规模，f(n)为语句关于n所占存储空间的函数。
一般情况下，一个程序运行时，除了存储本身指令、常数、变量和输入量之外，还需要存储对数据操作的存储单元，即算法在运行中的辅助单元。若算法执行时所需辅助空间相对于数据输入量而言是个常数，则此算法为原地工作，空间复杂度为O(1)。